#!/usr/bin/env node
/**
 * Database Migration Script
 *
 * Automatically checks for and creates missing tables:
 * - Better-Auth tables (user, session, account, verification)
 * - Setup Wizard tables (app_settings, workflow_registry)
 *
 * Runs on container startup before the main application.
 *
 * Usage: node scripts/db-migrate.mjs [--validate-only]
 *
 * Options:
 *   --validate-only  Only validate schema, don't run migrations
 *
 * Environment:
 *   DATABASE_URL - PostgreSQL connection string (required)
 *                  MUST point to 'dashboard' database, NOT 'n8n' database
 */

import pg from 'pg';

const { Pool } = pg;

// Command line flags
const VALIDATE_ONLY = process.argv.includes('--validate-only');

// Better-Auth required tables
const BETTER_AUTH_TABLES = ['user', 'session', 'account', 'verification'];

// Setup Wizard required tables
const SETUP_WIZARD_TABLES = ['app_settings', 'workflow_registry'];

// n8n-specific tables that should NOT exist in dashboard database
const N8N_SPECIFIC_TABLES = [
  'execution_entity',
  'workflow_entity',
  'webhook_entity',
  'credentials_entity',
];

// SQL to create Better-Auth tables
const MIGRATION_SQL = `
-- Better-Auth Core Schema
-- Auto-generated by db-migrate.mjs

-- User table - stores user information
CREATE TABLE IF NOT EXISTS "user" (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    "emailVerified" BOOLEAN NOT NULL DEFAULT FALSE,
    image TEXT,
    "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

-- Session table - stores session data for authenticated users
CREATE TABLE IF NOT EXISTS "session" (
    id TEXT PRIMARY KEY,
    "userId" TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
    token TEXT NOT NULL UNIQUE,
    "expiresAt" TIMESTAMP WITH TIME ZONE NOT NULL,
    "ipAddress" TEXT,
    "userAgent" TEXT,
    "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

-- Account table - stores OAuth provider account links (Google, etc.)
CREATE TABLE IF NOT EXISTS "account" (
    id TEXT PRIMARY KEY,
    "userId" TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
    "accountId" TEXT NOT NULL,
    "providerId" TEXT NOT NULL,
    "accessToken" TEXT,
    "refreshToken" TEXT,
    "idToken" TEXT,
    "accessTokenExpiresAt" TIMESTAMP WITH TIME ZONE,
    "refreshTokenExpiresAt" TIMESTAMP WITH TIME ZONE,
    scope TEXT,
    password TEXT,
    "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

-- Verification table - stores email verification and password reset tokens
CREATE TABLE IF NOT EXISTS "verification" (
    id TEXT PRIMARY KEY,
    identifier TEXT NOT NULL,
    value TEXT NOT NULL,
    "expiresAt" TIMESTAMP WITH TIME ZONE NOT NULL,
    "createdAt" TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    "updatedAt" TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_session_user_id ON "session"("userId");
CREATE INDEX IF NOT EXISTS idx_session_token ON "session"(token);
CREATE INDEX IF NOT EXISTS idx_session_expires ON "session"("expiresAt");
CREATE INDEX IF NOT EXISTS idx_account_user_id ON "account"("userId");
CREATE INDEX IF NOT EXISTS idx_account_provider ON "account"("providerId", "accountId");
CREATE INDEX IF NOT EXISTS idx_verification_identifier ON "verification"(identifier);
CREATE INDEX IF NOT EXISTS idx_verification_expires ON "verification"("expiresAt");
CREATE INDEX IF NOT EXISTS idx_user_email ON "user"(email);
`;

// SQL to create Setup Wizard tables (app_settings, workflow_registry)
const SETUP_WIZARD_SQL = `
-- Setup Wizard Schema
-- Auto-generated by db-migrate.mjs

-- Ensure pgcrypto extension exists (for gen_random_uuid)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Create or replace the timestamp update function (idempotent)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- Application Settings Table (Key-Value Store)
-- ============================================
CREATE TABLE IF NOT EXISTS app_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    setting_key VARCHAR(100) NOT NULL UNIQUE,
    setting_value JSONB NOT NULL,
    setting_type VARCHAR(50) DEFAULT 'string' CHECK (setting_type IN (
        'string', 'number', 'boolean', 'json', 'encrypted'
    )),
    description TEXT,
    is_sensitive BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_by VARCHAR(255)
);

CREATE INDEX IF NOT EXISTS idx_app_settings_key ON app_settings(setting_key);
CREATE INDEX IF NOT EXISTS idx_app_settings_sensitive ON app_settings(is_sensitive) WHERE is_sensitive = TRUE;

DROP TRIGGER IF EXISTS update_app_settings_updated_at ON app_settings;
CREATE TRIGGER update_app_settings_updated_at
    BEFORE UPDATE ON app_settings
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- Workflow Registry Table
-- ============================================
CREATE TABLE IF NOT EXISTS workflow_registry (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_name VARCHAR(255) NOT NULL,
    workflow_file VARCHAR(255) NOT NULL UNIQUE,
    n8n_workflow_id VARCHAR(100),
    n8n_workflow_version INTEGER DEFAULT 1,
    local_version VARCHAR(50) NOT NULL,
    local_checksum VARCHAR(64),
    webhook_paths JSONB DEFAULT '[]'::JSONB,
    is_active BOOLEAN DEFAULT FALSE,
    import_status VARCHAR(50) DEFAULT 'pending' CHECK (import_status IN (
        'pending', 'importing', 'imported', 'failed', 'update_available', 'updating'
    )),
    last_import_at TIMESTAMP WITH TIME ZONE,
    last_error TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_workflow_registry_name ON workflow_registry(workflow_name);
CREATE INDEX IF NOT EXISTS idx_workflow_registry_status ON workflow_registry(import_status);
CREATE INDEX IF NOT EXISTS idx_workflow_registry_n8n_id ON workflow_registry(n8n_workflow_id);
CREATE INDEX IF NOT EXISTS idx_workflow_registry_active ON workflow_registry(is_active) WHERE is_active = TRUE;

DROP TRIGGER IF EXISTS update_workflow_registry_updated_at ON workflow_registry;
CREATE TRIGGER update_workflow_registry_updated_at
    BEFORE UPDATE ON workflow_registry
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- Helper Functions
-- ============================================

CREATE OR REPLACE FUNCTION get_setting(p_key VARCHAR(100))
RETURNS JSONB AS $$
DECLARE
    v_value JSONB;
BEGIN
    SELECT setting_value INTO v_value
    FROM app_settings
    WHERE setting_key = p_key;
    RETURN v_value;
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION set_setting(
    p_key VARCHAR(100),
    p_value JSONB,
    p_type VARCHAR(50) DEFAULT 'string',
    p_description TEXT DEFAULT NULL,
    p_is_sensitive BOOLEAN DEFAULT FALSE,
    p_updated_by VARCHAR(255) DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO app_settings (setting_key, setting_value, setting_type, description, is_sensitive, updated_by)
    VALUES (p_key, p_value, p_type, p_description, p_is_sensitive, p_updated_by)
    ON CONFLICT (setting_key) DO UPDATE SET
        setting_value = EXCLUDED.setting_value,
        setting_type = COALESCE(EXCLUDED.setting_type, app_settings.setting_type),
        description = COALESCE(EXCLUDED.description, app_settings.description),
        is_sensitive = COALESCE(EXCLUDED.is_sensitive, app_settings.is_sensitive),
        updated_by = EXCLUDED.updated_by;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION is_n8n_configured()
RETURNS BOOLEAN AS $$
DECLARE
    v_api_url JSONB;
    v_api_key JSONB;
BEGIN
    SELECT setting_value INTO v_api_url FROM app_settings WHERE setting_key = 'n8n.api_url';
    SELECT setting_value INTO v_api_key FROM app_settings WHERE setting_key = 'n8n.api_key';
    RETURN v_api_url IS NOT NULL
       AND v_api_key IS NOT NULL
       AND v_api_url::TEXT != '""'
       AND v_api_key::TEXT != '""';
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION is_setup_complete()
RETURNS BOOLEAN AS $$
DECLARE
    v_completed JSONB;
BEGIN
    SELECT setting_value INTO v_completed
    FROM app_settings
    WHERE setting_key = 'setup.wizard_completed';
    RETURN v_completed IS NOT NULL AND v_completed::TEXT = 'true';
END;
$$ LANGUAGE plpgsql STABLE;

-- ============================================
-- Views
-- ============================================

CREATE OR REPLACE VIEW workflow_import_summary AS
SELECT
    COUNT(*) AS total_workflows,
    COUNT(*) FILTER (WHERE import_status = 'imported') AS imported_count,
    COUNT(*) FILTER (WHERE import_status = 'pending') AS pending_count,
    COUNT(*) FILTER (WHERE import_status = 'failed') AS failed_count,
    COUNT(*) FILTER (WHERE import_status = 'update_available') AS updates_available,
    COUNT(*) FILTER (WHERE is_active = TRUE) AS active_count,
    MAX(last_import_at) AS last_import_time
FROM workflow_registry;

CREATE OR REPLACE VIEW setup_status AS
SELECT
    is_n8n_configured() AS n8n_configured,
    is_setup_complete() AS wizard_completed,
    (SELECT setting_value::TEXT FROM app_settings WHERE setting_key = 'n8n.api_url') AS n8n_url,
    (SELECT setting_value::TEXT FROM app_settings WHERE setting_key = 'setup.wizard_completed_at') AS completed_at,
    (SELECT COUNT(*) FROM workflow_registry WHERE import_status = 'imported') AS workflows_imported,
    (SELECT COUNT(*) FROM workflow_registry) AS workflows_total;
`;

/**
 * Check which tables are missing from the database
 */
async function checkMissingTables(pool, requiredTables) {
  const query = `
    SELECT table_name
    FROM information_schema.tables
    WHERE table_schema = 'public'
    AND table_name = ANY($1)
  `;

  const result = await pool.query(query, [requiredTables]);
  const existingTables = result.rows.map(row => row.table_name);
  const missingTables = requiredTables.filter(t => !existingTables.includes(t));

  return { existingTables, missingTables };
}

/**
 * Get current database name
 */
async function getCurrentDatabase(pool) {
  const result = await pool.query('SELECT current_database()');
  return result.rows[0]?.current_database || 'unknown';
}

/**
 * Check if any n8n-specific tables exist (indicates wrong database)
 */
async function checkForN8nTables(pool) {
  const query = `
    SELECT table_name
    FROM information_schema.tables
    WHERE table_schema = 'public'
    AND table_name = ANY($1)
  `;

  const result = await pool.query(query, [N8N_SPECIFIC_TABLES]);
  return result.rows.map(row => row.table_name);
}

/**
 * Get column type for a specific table and column
 */
async function getColumnType(pool, tableName, columnName) {
  const result = await pool.query(`
    SELECT data_type
    FROM information_schema.columns
    WHERE table_name = $1 AND column_name = $2
  `, [tableName, columnName]);

  return result.rows[0]?.data_type || null;
}

/**
 * Validate that we're connected to the correct database (dashboard, not n8n)
 * and that existing user table (if any) has compatible schema
 */
async function validateDatabaseConfig(pool) {
  const currentDb = await getCurrentDatabase(pool);
  const errors = [];
  const warnings = [];

  // Check 1: Warn if not connected to 'dashboard' database
  if (currentDb !== 'dashboard') {
    warnings.push(
      `Connected to database '${currentDb}' instead of 'dashboard'.` +
      `\n   ‚Üí Ensure DATABASE_URL points to: postgresql://<user>:<pass>@host:5432/dashboard`
    );
  }

  // Check 2: Error if n8n-specific tables exist (definitely wrong database)
  const n8nTables = await checkForN8nTables(pool);
  if (n8nTables.length > 0) {
    errors.push(
      `‚ùå CRITICAL: Found n8n-specific tables: ${n8nTables.join(', ')}` +
      `\n   ‚Üí DATABASE_URL is pointing to n8n's database, NOT the dashboard database.` +
      `\n   ‚Üí This will cause foreign key constraint failures.` +
      `\n` +
      `\n   FIX: Change DATABASE_URL to point to 'dashboard' database:` +
      `\n        postgresql://<user>:<pass>@postgres:5432/dashboard` +
      `\n` +
      `\n   The 'dashboard' database is created by init-scripts/00-aaa-create-databases.sql`
    );
  }

  // Check 3: If user table exists, verify it has TEXT id (not UUID)
  const userIdType = await getColumnType(pool, 'user', 'id');
  if (userIdType) {
    if (userIdType === 'uuid') {
      errors.push(
        `‚ùå CRITICAL: user.id column has type 'uuid' (expected 'text')` +
        `\n   ‚Üí This is likely n8n's user table, not Better-Auth's user table.` +
        `\n   ‚Üí DATABASE_URL is pointing to the wrong database.` +
        `\n` +
        `\n   FIX: Change DATABASE_URL to point to 'dashboard' database:` +
        `\n        postgresql://<user>:<pass>@postgres:5432/dashboard` +
        `\n` +
        `\n   Current database: ${currentDb}` +
        `\n   Expected database: dashboard`
      );
    } else if (userIdType !== 'text' && userIdType !== 'character varying') {
      errors.push(
        `‚ùå user.id column has unexpected type '${userIdType}' (expected 'text')` +
        `\n   ‚Üí Better-Auth requires user.id to be TEXT type.`
      );
    }
  }

  return { errors, warnings, currentDb };
}

/**
 * Run database migrations
 */
async function runMigrations() {
  const databaseUrl = process.env.DATABASE_URL;

  if (!databaseUrl) {
    console.error('‚ùå DATABASE_URL environment variable is not set');
    process.exit(1);
  }

  console.log('üîÑ Database Migration Check');
  console.log('‚îÅ'.repeat(50));

  // Warn if DATABASE_URL doesn't end with /dashboard
  if (!databaseUrl.includes('/dashboard')) {
    console.log('‚ö†Ô∏è  Warning: DATABASE_URL may not point to dashboard database');
    console.log('   Expected: postgresql://<user>:<pass>@host:5432/dashboard');
  }

  const pool = new Pool({ connectionString: databaseUrl });

  try {
    // Test connection
    console.log('üì° Connecting to database...');
    await pool.query('SELECT 1');
    console.log('‚úÖ Database connection successful');

    // Validate database configuration BEFORE running migrations
    console.log('\nüîç Validating database configuration...');
    const { errors, warnings, currentDb } = await validateDatabaseConfig(pool);

    console.log(`   Current database: ${currentDb}`);

    // Show warnings
    for (const warning of warnings) {
      console.log(`\n‚ö†Ô∏è  ${warning}`);
    }

    // If there are errors, stop immediately
    if (errors.length > 0) {
      console.log('\n' + '‚ïê'.repeat(60));
      console.log('DATABASE CONFIGURATION ERRORS DETECTED');
      console.log('‚ïê'.repeat(60));
      for (const error of errors) {
        console.log(`\n${error}`);
      }
      console.log('\n' + '‚ïê'.repeat(60));
      console.log('Migration aborted due to configuration errors.');
      console.log('‚ïê'.repeat(60));
      process.exit(1);
    }

    // If validate-only mode, stop here
    if (VALIDATE_ONLY) {
      console.log('\n‚úÖ Database configuration validation passed');
      console.log('   (--validate-only mode, skipping migrations)');
      console.log('‚îÅ'.repeat(50));
      return;
    }

    // Check for missing Better-Auth tables
    console.log('\nüîç Checking for Better-Auth tables...');
    const { existingTables: authExisting, missingTables: authMissing } =
      await checkMissingTables(pool, BETTER_AUTH_TABLES);

    if (authExisting.length > 0) {
      console.log(`‚úÖ Found tables: ${authExisting.join(', ')}`);
    }

    // Check for missing Setup Wizard tables
    console.log('\nüîç Checking for Setup Wizard tables...');
    const { existingTables: wizardExisting, missingTables: wizardMissing } =
      await checkMissingTables(pool, SETUP_WIZARD_TABLES);

    if (wizardExisting.length > 0) {
      console.log(`‚úÖ Found tables: ${wizardExisting.join(', ')}`);
    }

    // Check if any migrations are needed
    const totalMissing = [...authMissing, ...wizardMissing];
    if (totalMissing.length === 0) {
      console.log('\n‚úÖ All required tables exist - no migration needed');
      console.log('‚îÅ'.repeat(50));
      return;
    }

    console.log(`\n‚ö†Ô∏è  Missing tables: ${totalMissing.join(', ')}`);
    console.log('\nüöÄ Running migrations...');

    // Run Better-Auth migrations if needed
    if (authMissing.length > 0) {
      console.log('   Creating Better-Auth tables...');
      await pool.query(MIGRATION_SQL);

      // Verify Better-Auth tables were created
      const { missingTables: authStillMissing } =
        await checkMissingTables(pool, BETTER_AUTH_TABLES);

      if (authStillMissing.length > 0) {
        console.error(`‚ùå Failed to create Better-Auth tables: ${authStillMissing.join(', ')}`);
        process.exit(1);
      }
      console.log(`   ‚úÖ Created: ${authMissing.join(', ')}`);
    }

    // Run Setup Wizard migrations if needed
    if (wizardMissing.length > 0) {
      console.log('   Creating Setup Wizard tables...');
      await pool.query(SETUP_WIZARD_SQL);

      // Verify Setup Wizard tables were created
      const { missingTables: wizardStillMissing } =
        await checkMissingTables(pool, SETUP_WIZARD_TABLES);

      if (wizardStillMissing.length > 0) {
        console.error(`‚ùå Failed to create Setup Wizard tables: ${wizardStillMissing.join(', ')}`);
        process.exit(1);
      }
      console.log(`   ‚úÖ Created: ${wizardMissing.join(', ')}`);
    }

    console.log('\n‚úÖ All migrations completed successfully');
    console.log('‚îÅ'.repeat(50));

  } catch (error) {
    console.error('‚ùå Migration failed:', error.message);

    // Provide helpful error messages
    if (error.code === 'ECONNREFUSED') {
      console.error('   ‚Üí Database server is not reachable');
      console.error('   ‚Üí Check if PostgreSQL is running and DATABASE_URL is correct');
    } else if (error.code === '28P01') {
      console.error('   ‚Üí Authentication failed');
      console.error('   ‚Üí Check your database credentials in DATABASE_URL');
    } else if (error.code === '3D000') {
      console.error('   ‚Üí Database does not exist');
      console.error('   ‚Üí Make sure the database has been created');
      console.error('   ‚Üí The dashboard database should be created by:');
      console.error('     init-scripts/00-aaa-create-databases.sql');
    } else if (error.message.includes('foreign key constraint')) {
      console.error('\n   ‚Üí FOREIGN KEY CONSTRAINT ERROR');
      console.error('   ‚Üí This usually means DATABASE_URL points to the wrong database.');
      console.error('   ‚Üí n8n uses UUID for user.id, Better-Auth uses TEXT.');
      console.error('\n   FIX: Change DATABASE_URL to point to dashboard database:');
      console.error('        postgresql://<user>:<pass>@postgres:5432/dashboard');
    }

    process.exit(1);
  } finally {
    await pool.end();
  }
}

// Run migrations
runMigrations();
