{
  "name": "AI Product Factory - Decision Logger",
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "operation",
              "type": "string"
            },
            {
              "name": "project_id",
              "type": "string"
            },
            {
              "name": "session_id",
              "type": "string"
            },
            {
              "name": "phase",
              "type": "string"
            },
            {
              "name": "entry_type",
              "type": "string"
            },
            {
              "name": "content",
              "type": "string"
            },
            {
              "name": "metadata",
              "type": "string"
            }
          ]
        }
      },
      "id": "subworkflow-entry",
      "name": "Subworkflow Entry Point",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [0, 0]
    },
    {
      "parameters": {
        "jsCode": "// Decision Logger - Input Validator\n// Validates incoming parameters and prepares logging context\n\nconst input = $input.first().json;\n\n// Validate required fields\nconst operation = input.operation;\nif (!operation) {\n  throw new Error('Missing required field: operation');\n}\n\nconst validOperations = ['log_decision', 'log_iteration', 'log_approval', 'log_phase_start', 'log_phase_end', 'log_governance_batch'];\nif (!validOperations.includes(operation)) {\n  throw new Error(`Invalid operation: ${operation}. Must be one of: ${validOperations.join(', ')}`);\n}\n\nconst project_id = input.project_id;\nif (!project_id) {\n  throw new Error('Missing required field: project_id');\n}\n\nconst session_id = input.session_id || 'unknown_session';\nconst phase = input.phase || 'unknown';\nconst entry_type = input.entry_type || operation;\nconst content = input.content || '';\n\n// Parse metadata if it's a string\nlet metadata = {};\nif (input.metadata) {\n  if (typeof input.metadata === 'string') {\n    try {\n      metadata = JSON.parse(input.metadata);\n    } catch (e) {\n      metadata = { raw: input.metadata };\n    }\n  } else {\n    metadata = input.metadata;\n  }\n}\n\n// Generate timestamp\nconst timestamp = new Date().toISOString();\nconst timestampFormatted = new Date().toLocaleString('en-US', {\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  second: '2-digit',\n  hour12: false\n});\n\n// Generate request ID for tracing\nconst request_id = `log_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n\n// Extract iteration-related fields for PostgreSQL\nconst iteration = metadata.iteration !== undefined ? parseInt(metadata.iteration) : null;\nconst agent_name = metadata.agent || null;\nconst score = metadata.score !== undefined ? parseFloat(metadata.score) : null;\nconst issues_count = metadata.issues && Array.isArray(metadata.issues) ? metadata.issues.length : null;\n\n// S3 paths\nconst s3_key = `projects/${project_id}/decision_log.md`;\n\nreturn {\n  json: {\n    operation,\n    project_id,\n    session_id,\n    phase,\n    entry_type,\n    content,\n    metadata,\n    timestamp,\n    timestamp_formatted: timestampFormatted,\n    request_id,\n    s3_key,\n    // Fields for PostgreSQL\n    iteration,\n    agent_name,\n    score,\n    issues_count\n  }\n};"
      },
      "id": "validate-input",
      "name": "Input Validator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 0]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.operation }}",
                    "rightValue": "log_decision",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "log_decision"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.operation }}",
                    "rightValue": "log_iteration",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "log_iteration"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.operation }}",
                    "rightValue": "log_approval",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "log_approval"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.operation }}",
                    "rightValue": "log_phase_start",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "log_phase_start"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.operation }}",
                    "rightValue": "log_phase_end",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "log_phase_end"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.operation }}",
                    "rightValue": "log_governance_batch",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "log_governance_batch"
            }
          ]
        },
        "options": {}
      },
      "id": "operation-router",
      "name": "Operation Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [440, 0]
    },
    {
      "parameters": {
        "jsCode": "// Format Decision Log Entry\n// Creates a markdown entry for tech standard or key decision\n\nconst data = $input.first().json;\nconst metadata = data.metadata || {};\n\nlet entry = `\\n#### [${data.timestamp_formatted}] ${data.entry_type}\\n`;\n\n// Format based on entry type\nif (data.entry_type === 'tech_standard_discovery') {\n  entry += `- **Found**: ${metadata.name || 'Unknown'}\\n`;\n  entry += `- **Type**: ${metadata.type || 'unknown'}\\n`;\n  entry += `- **Source**: ${metadata.source || 'Unknown document'}\\n`;\n  entry += `- **Confidence**: ${metadata.confidence ? (metadata.confidence * 100).toFixed(0) + '%' : 'N/A'}\\n`;\n  if (metadata.description) {\n    entry += `- **Description**: ${metadata.description}\\n`;\n  }\n  entry += `- **User Decision**: ${metadata.user_decision || 'Pending'}\\n`;\n  if (metadata.stored_in) {\n    entry += `- **Stored In**: ${metadata.stored_in}\\n`;\n  }\n} else if (data.entry_type === 'architecture_decision') {\n  entry += `- **Decision**: ${metadata.decision || data.content}\\n`;\n  entry += `- **Rationale**: ${metadata.rationale || 'N/A'}\\n`;\n  entry += `- **Status**: ${metadata.status || 'recorded'}\\n`;\n  if (metadata.alternatives) {\n    entry += `- **Alternatives Considered**: ${metadata.alternatives}\\n`;\n  }\n} else {\n  // Generic decision format\n  entry += `- **Decision**: ${data.content}\\n`;\n  if (metadata.reason) {\n    entry += `- **Reason**: ${metadata.reason}\\n`;\n  }\n  if (metadata.approved_by) {\n    entry += `- **Approved By**: ${metadata.approved_by}\\n`;\n  }\n}\n\nentry += '\\n';\n\nreturn {\n  json: {\n    ...data,\n    formatted_entry: entry,\n    log_section: `Phase ${data.phase}: ${data.entry_type}`\n  }\n};"
      },
      "id": "format-decision",
      "name": "Format Decision Entry",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, -300]
    },
    {
      "parameters": {
        "jsCode": "// Format Iteration Log Entry\n// Creates a markdown entry for adversarial loop iterations\n\nconst data = $input.first().json;\nconst metadata = data.metadata || {};\n\nlet entry = `\\n#### [${data.timestamp_formatted}] ${data.entry_type}\\n`;\n\n// Format iteration entry\nconst iteration = metadata.iteration || 'N/A';\nconst agent = metadata.agent || 'Unknown';\nconst score = metadata.score;\nconst action = metadata.action || 'processed';\n\nentry += `- **Iteration**: ${iteration}\\n`;\nentry += `- **Agent**: ${agent}\\n`;\n\nif (score !== undefined && score !== null) {\n  entry += `- **Score**: ${score}/100\\n`;\n}\n\nif (metadata.issues && Array.isArray(metadata.issues)) {\n  entry += `- **Key Issues**:\\n`;\n  metadata.issues.forEach(issue => {\n    const severity = issue.severity || 'unknown';\n    const detail = issue.detail || issue.criterion || issue;\n    entry += `  - ${detail} (${severity})\\n`;\n  });\n}\n\nif (metadata.strengths && Array.isArray(metadata.strengths)) {\n  entry += `- **Strengths**: ${metadata.strengths.join(', ')}\\n`;\n}\n\nentry += `- **Action**: ${action}\\n`;\n\nif (metadata.filename) {\n  entry += `- **Saved To**: ${metadata.filename}\\n`;\n}\n\nentry += '\\n';\n\nreturn {\n  json: {\n    ...data,\n    formatted_entry: entry,\n    log_section: `Phase ${data.phase}: Iteration ${iteration}`\n  }\n};"
      },
      "id": "format-iteration",
      "name": "Format Iteration Entry",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, -100]
    },
    {
      "parameters": {
        "jsCode": "// Format Approval Log Entry\n// Creates a markdown entry for human approvals\n\nconst data = $input.first().json;\nconst metadata = data.metadata || {};\n\nlet entry = `\\n#### [${data.timestamp_formatted}] Human Approval\\n`;\n\nentry += `- **Item**: ${metadata.item || data.content}\\n`;\nentry += `- **Decision**: ${metadata.decision || 'Approved'}\\n`;\n\nif (metadata.scope) {\n  entry += `- **Scope**: ${metadata.scope}\\n`;\n}\n\nif (metadata.notes) {\n  entry += `- **Notes**: ${metadata.notes}\\n`;\n}\n\nif (metadata.webhook_response) {\n  entry += `- **Response Time**: ${metadata.response_time || 'N/A'}\\n`;\n}\n\nentry += '\\n';\n\nreturn {\n  json: {\n    ...data,\n    formatted_entry: entry,\n    log_section: `Phase ${data.phase}: Human Approval`\n  }\n};"
      },
      "id": "format-approval",
      "name": "Format Approval Entry",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 100]
    },
    {
      "parameters": {
        "jsCode": "// Format Phase Start Entry\n// Creates a markdown section header for phase start\n\nconst data = $input.first().json;\nconst metadata = data.metadata || {};\n\nconst phaseNames = {\n  '0': 'Context Scavenging',\n  '1': 'Product Vision Loop',\n  '2': 'Architecture Loop',\n  '3': 'Final Audit'\n};\n\nconst phaseName = phaseNames[data.phase] || `Phase ${data.phase}`;\n\nlet entry = `\\n---\\n\\n### Phase ${data.phase}: ${phaseName}\\n\\n`;\nentry += `**Started**: ${data.timestamp_formatted}\\n`;\n\nif (metadata.description) {\n  entry += `**Description**: ${metadata.description}\\n`;\n}\n\nif (metadata.config) {\n  entry += `**Configuration**:\\n`;\n  entry += `- Max Iterations: ${metadata.config.max_iterations || 5}\\n`;\n  entry += `- Score Threshold: ${metadata.config.score_threshold || 90}\\n`;\n}\n\nentry += '\\n';\n\nreturn {\n  json: {\n    ...data,\n    formatted_entry: entry,\n    log_section: `Phase ${data.phase} Start`\n  }\n};"
      },
      "id": "format-phase-start",
      "name": "Format Phase Start",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// Format Phase End Entry\n// Creates a markdown summary for phase completion\n\nconst data = $input.first().json;\nconst metadata = data.metadata || {};\n\nconst phaseNames = {\n  '0': 'Context Scavenging',\n  '1': 'Product Vision Loop',\n  '2': 'Architecture Loop',\n  '3': 'Final Audit'\n};\n\nconst phaseName = phaseNames[data.phase] || `Phase ${data.phase}`;\n\nlet entry = `\\n#### Phase ${data.phase} Summary\\n\\n`;\nentry += `**Completed**: ${data.timestamp_formatted}\\n`;\nentry += `**Status**: ${metadata.status || 'completed'}\\n`;\n\nif (metadata.duration) {\n  entry += `**Duration**: ${metadata.duration}\\n`;\n}\n\nif (metadata.total_iterations !== undefined) {\n  entry += `**Total Iterations**: ${metadata.total_iterations}\\n`;\n}\n\nif (metadata.final_score !== undefined) {\n  entry += `**Final Score**: ${metadata.final_score}/100\\n`;\n}\n\nif (metadata.artifacts && Array.isArray(metadata.artifacts)) {\n  entry += `**Artifacts Created**:\\n`;\n  metadata.artifacts.forEach(artifact => {\n    entry += `- ${artifact}\\n`;\n  });\n}\n\nif (metadata.key_decisions && Array.isArray(metadata.key_decisions)) {\n  entry += `**Key Decisions**:\\n`;\n  metadata.key_decisions.forEach(decision => {\n    entry += `- ${decision}\\n`;\n  });\n}\n\nentry += '\\n---\\n';\n\nreturn {\n  json: {\n    ...data,\n    formatted_entry: entry,\n    log_section: `Phase ${data.phase} End`\n  }\n};"
      },
      "id": "format-phase-end",
      "name": "Format Phase End",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 500]
    },
    {
      "parameters": {
        "jsCode": "// Format Governance Batch Entry\n// Creates a markdown entry for batch governance decisions from Tech Stack Configurator\n\nconst data = $input.first().json;\nconst metadata = data.metadata || {};\n\nlet entry = `\\n#### [${data.timestamp_formatted}] Batch Governance Decision\\n\\n`;\n\nentry += `- **Scavenging ID**: ${metadata.scavenging_id || 'N/A'}\\n`;\nentry += `- **Total Technologies**: ${metadata.total_techs || 0}\\n`;\n\n// Summary counts\nconst decisions = metadata.decisions || [];\nconst approvedGlobal = decisions.filter(d => d.action === 'approve' && d.scope === 'global').length;\nconst approvedLocal = decisions.filter(d => d.action === 'approve' && d.scope === 'local').length;\nconst skipped = decisions.filter(d => d.action === 'skip').length;\n\nentry += `- **Approved (Global)**: ${approvedGlobal}\\n`;\nentry += `- **Approved (Local)**: ${approvedLocal}\\n`;\nentry += `- **Skipped**: ${skipped}\\n\\n`;\n\n// Detail each decision\nif (decisions.length > 0) {\n  entry += `**Decisions:**\\n\\n`;\n  entry += `| Technology | Action | Scope | Alternative |\\n`;\n  entry += `|------------|--------|-------|-------------|\\n`;\n  \n  for (const decision of decisions) {\n    const techName = decision.tech_name || decision.tech_id;\n    const action = decision.action || 'skip';\n    const scope = decision.scope || '-';\n    const alt = decision.selected_alternative || '-';\n    entry += `| ${techName} | ${action} | ${scope} | ${alt} |\\n`;\n  }\n  entry += '\\n';\n}\n\nentry += '\\n';\n\nreturn {\n  json: {\n    ...data,\n    formatted_entry: entry,\n    log_section: `Phase ${data.phase}: Batch Governance`\n  }\n};"
      },
      "id": "format-governance-batch",
      "name": "Format Governance Batch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 700]
    },
    {
      "parameters": {
        "jsCode": "// Pass through formatted entry from whichever operation was invoked\nconst data = $input.first().json;\nreturn { json: data };"
      },
      "id": "merge-formatted",
      "name": "Merge Formatted Entries",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [920, 200]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "name",
          "value": "AI Product Factory - S3 Storage Operations"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "operation": "download_artifact",
            "project_id": "={{ $json.project_id }}",
            "artifact_type": "decision_log",
            "filename": "decision_log.md"
          }
        }
      },
      "id": "download-existing-log-s3",
      "name": "Download Existing Log from S3",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [1140, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Check if decision log exists in S3 and prepare content\n\nconst formattedData = $('Merge Formatted Entries').item.json;\nconst s3Result = $input.first().json;\n\nlet existingContent = '';\nlet fileExists = false;\n\n// Check if download was successful\nif (s3Result.success && s3Result.content) {\n  existingContent = s3Result.content;\n  fileExists = true;\n} else if (s3Result.error && s3Result.error.includes('NoSuchKey')) {\n  // File doesn't exist yet - that's OK\n  fileExists = false;\n  existingContent = '';\n}\n\n// Build new content\nlet newContent;\nif (fileExists) {\n  // Append to existing\n  newContent = existingContent + formattedData.formatted_entry;\n} else {\n  // Create new log with header\n  const header = `# Decision Log - ${formattedData.project_id}\\n\\n`;\n  const sessionHeader = `## Session: ${formattedData.session_id}\\n**Started**: ${formattedData.timestamp_formatted}\\n`;\n  newContent = header + sessionHeader + formattedData.formatted_entry;\n}\n\nreturn {\n  json: {\n    ...formattedData,\n    file_exists: fileExists,\n    file_content: newContent,\n    action: fileExists ? 'update' : 'create'\n  }\n};"
      },
      "id": "prepare-content",
      "name": "Prepare Log Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1360, 200]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "name",
          "value": "AI Product Factory - S3 Storage Operations"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "operation": "upload_artifact",
            "project_id": "={{ $json.project_id }}",
            "artifact_type": "decision_log",
            "filename": "decision_log.md",
            "content": "={{ $json.file_content }}",
            "content_type": "text/markdown"
          }
        }
      },
      "id": "upload-log-s3",
      "name": "Upload Decision Log to S3",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [1580, 200]
    },
    {
      "parameters": {
        "jsCode": "// Build success output after S3 upload\n\nconst contentData = $('Prepare Log Content').item.json;\nconst s3Result = $input.first().json;\n\nconst success = s3Result.success || false;\n\nreturn {\n  json: {\n    operation: contentData.operation,\n    project_id: contentData.project_id,\n    session_id: contentData.session_id,\n    phase: contentData.phase,\n    status: success ? 'success' : 'error',\n    message: success \n      ? `Decision log ${contentData.action === 'create' ? 'created' : 'updated'} successfully in S3`\n      : `Failed to save decision log: ${s3Result.error || 'Unknown error'}`,\n    request_id: contentData.request_id,\n    s3_key: contentData.s3_key,\n    timestamp: contentData.timestamp,\n    log_section: contentData.log_section,\n    file_content: contentData.file_content,\n    action: contentData.action\n  }\n};"
      },
      "id": "success-output",
      "name": "Success Output Builder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1800, 200]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "name",
          "value": "AI Product Factory - S3 Storage Operations"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "operation": "insert_decision_log_entry",
            "project_id": "={{ $('Input Validator').item.json.project_id }}",
            "session_id": "={{ $('Input Validator').item.json.session_id }}",
            "entry_type": "={{ $('Input Validator').item.json.entry_type }}",
            "phase": "={{ $('Input Validator').item.json.phase }}",
            "iteration": "={{ $('Input Validator').item.json.iteration }}",
            "content": "={{ $('Input Validator').item.json.content }}",
            "metadata": "={{ JSON.stringify($('Input Validator').item.json.metadata) }}",
            "agent_name": "={{ $('Input Validator').item.json.agent_name }}",
            "score": "={{ $('Input Validator').item.json.score }}",
            "issues_count": "={{ $('Input Validator').item.json.issues_count }}"
          }
        }
      },
      "id": "sync-postgres-entry",
      "name": "Sync to PostgreSQL",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [2020, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Build final output with sync results\n\nconst successData = $('Success Output Builder').item.json;\nconst pgResult = $input.first().json;\n\nconst pgSuccess = pgResult.success || false;\n\nreturn {\n  json: {\n    operation: successData.operation,\n    project_id: successData.project_id,\n    session_id: successData.session_id,\n    phase: successData.phase,\n    status: successData.status,\n    message: successData.message,\n    request_id: successData.request_id,\n    s3_key: successData.s3_key,\n    timestamp: successData.timestamp,\n    log_section: successData.log_section,\n    s3_synced: successData.status === 'success',\n    postgres_synced: pgSuccess\n  }\n};"
      },
      "id": "output-merge",
      "name": "Subworkflow Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2240, 200]
    }
  ],
  "connections": {
    "Subworkflow Entry Point": {
      "main": [
        [
          {
            "node": "Input Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Input Validator": {
      "main": [
        [
          {
            "node": "Operation Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Operation Router": {
      "main": [
        [
          {
            "node": "Format Decision Entry",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format Iteration Entry",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format Approval Entry",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format Phase Start",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format Phase End",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format Governance Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Decision Entry": {
      "main": [
        [
          {
            "node": "Merge Formatted Entries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Iteration Entry": {
      "main": [
        [
          {
            "node": "Merge Formatted Entries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Approval Entry": {
      "main": [
        [
          {
            "node": "Merge Formatted Entries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Phase Start": {
      "main": [
        [
          {
            "node": "Merge Formatted Entries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Phase End": {
      "main": [
        [
          {
            "node": "Merge Formatted Entries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Governance Batch": {
      "main": [
        [
          {
            "node": "Merge Formatted Entries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Formatted Entries": {
      "main": [
        [
          {
            "node": "Download Existing Log from S3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Existing Log from S3": {
      "main": [
        [
          {
            "node": "Prepare Log Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Log Content": {
      "main": [
        [
          {
            "node": "Upload Decision Log to S3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Decision Log to S3": {
      "main": [
        [
          {
            "node": "Success Output Builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Success Output Builder": {
      "main": [
        [
          {
            "node": "Sync to PostgreSQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sync to PostgreSQL": {
      "main": [
        [
          {
            "node": "Subworkflow Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "2",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "ai-product-factory"
  },
  "id": "ai-product-factory-decision-logger",
  "tags": [
    {
      "id": "ai-product-factory",
      "name": "AI Product Factory"
    }
  ]
}
